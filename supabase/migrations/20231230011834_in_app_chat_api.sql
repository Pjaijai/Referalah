create type "public"."conversation_status" as enum ('active', 'inactive');

create type "public"."message_status" as enum ('active', 'inactive');

create table "public"."conversation" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default (now() AT TIME ZONE 'utc'::text),
    "sender_uuid" uuid not null,
    "receiver_uuid" uuid not null,
    "uuid" uuid not null default gen_random_uuid(),
    "is_receiver_accepted" boolean not null default false,
    "status" conversation_status not null default 'active'::conversation_status,
    "is_receiver_seen" boolean not null default false,
    "is_sender_seen" boolean not null default false,
    "last_message_uuid" uuid
);


alter table "public"."conversation" enable row level security;

create table "public"."message" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default (now() AT TIME ZONE 'utc'::text),
    "sender_uuid" uuid not null,
    "body" character varying not null,
    "uuid" uuid not null default gen_random_uuid(),
    "status" message_status not null default 'active'::message_status,
    "conversation_uuid" uuid not null
);


alter table "public"."message" enable row level security;

CREATE UNIQUE INDEX conversation_pkey ON public.conversation USING btree (id);

CREATE UNIQUE INDEX conversation_uuid_key ON public.conversation USING btree (uuid);

CREATE UNIQUE INDEX message_id_key ON public.message USING btree (id);

CREATE UNIQUE INDEX message_pkey ON public.message USING btree (id);

CREATE UNIQUE INDEX message_uuid_key ON public.message USING btree (uuid);

alter table "public"."conversation" add constraint "conversation_pkey" PRIMARY KEY using index "conversation_pkey";

alter table "public"."message" add constraint "message_pkey" PRIMARY KEY using index "message_pkey";

alter table "public"."conversation" add constraint "conversation_last_message_uuid_fkey" FOREIGN KEY (last_message_uuid) REFERENCES message(uuid) ON DELETE SET NULL not valid;

alter table "public"."conversation" validate constraint "conversation_last_message_uuid_fkey";

alter table "public"."conversation" add constraint "conversation_receiver_uuid_fkey" FOREIGN KEY (receiver_uuid) REFERENCES "user"(uuid) not valid;

alter table "public"."conversation" validate constraint "conversation_receiver_uuid_fkey";

alter table "public"."conversation" add constraint "conversation_sender_uuid_fkey" FOREIGN KEY (sender_uuid) REFERENCES "user"(uuid) not valid;

alter table "public"."conversation" validate constraint "conversation_sender_uuid_fkey";

alter table "public"."conversation" add constraint "conversation_uuid_key" UNIQUE using index "conversation_uuid_key";

alter table "public"."message" add constraint "message_body_check" CHECK ((length((body)::text) < 4001)) not valid;

alter table "public"."message" validate constraint "message_body_check";

alter table "public"."message" add constraint "message_conversation_uuid_fkey" FOREIGN KEY (conversation_uuid) REFERENCES conversation(uuid) not valid;

alter table "public"."message" validate constraint "message_conversation_uuid_fkey";

alter table "public"."message" add constraint "message_id_key" UNIQUE using index "message_id_key";

alter table "public"."message" add constraint "message_sender_uuid_fkey" FOREIGN KEY (sender_uuid) REFERENCES "user"(uuid) not valid;

alter table "public"."message" validate constraint "message_sender_uuid_fkey";

alter table "public"."message" add constraint "message_uuid_key" UNIQUE using index "message_uuid_key";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.find_conversation(user1_uuid uuid, user2_uuid uuid)
 RETURNS TABLE(id bigint, created_at timestamp with time zone, sender_uuid uuid, receiver_uuid uuid, uuid uuid, is_receiver_accepted boolean, status conversation_status, is_receiver_seen boolean, is_sender_seen boolean, last_message_uuid uuid)
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN QUERY
    SELECT c.id,
           c.created_at,
           c.sender_uuid,
           c.receiver_uuid,
           c.uuid,
           c.is_receiver_accepted,
           c.status,
           c.is_receiver_seen,
           c.is_sender_seen,
           c.last_message_uuid
    FROM public.conversation c
    WHERE 
      (c.sender_uuid = user1_uuid AND c.receiver_uuid = user2_uuid)
      OR
      (c.sender_uuid = user2_uuid AND c.receiver_uuid = user1_uuid);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_conversation_update()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.id := OLD.id; -- Prevent mutation of 'id'
  NEW.created_at := OLD.created_at; -- Prevent mutation of 'created_at'
  NEW.sender_uuid := OLD.sender_uuid; -- Prevent mutation of 'sender_uuid'
  NEW.receiver_uuid := OLD.receiver_uuid; -- Prevent mutation of 'receiver_uuid'
  NEW.uuid := OLD.uuid; -- Prevent mutation of 'uuid'
  NEW.status := OLD.status; -- Prevent mutation of 'status'

  -- Check if the authenticated user is the receiver and trying to mutate is_receiver_accepted and is_receiver_seen
  IF auth.uid() != OLD.receiver_uuid AND (
    NEW.is_receiver_accepted != OLD.is_receiver_accepted
    OR NEW.is_receiver_seen != OLD.is_receiver_seen
  ) THEN
    RAISE EXCEPTION 'Not allowed to update is_receiver_accepted or is_receiver_seen.';
  END IF;

  -- Check if the authenticated user is the sender and trying to mutate is_sender_seen
  IF auth.uid() != OLD.sender_uuid AND (NEW.is_sender_seen != OLD.is_sender_seen) THEN
    RAISE EXCEPTION 'Not allowed to update is_sender_seen.';
  END IF;

  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_message_update()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.id := OLD.id; -- Prevent mutation of 'id'
  NEW.created_at := OLD.created_at; -- Prevent mutation of 'created_at'
  NEW.sender_uuid := OLD.sender_uuid; -- Prevent mutation of 'sender_uuid'
  NEW.uuid := OLD.uuid; -- Prevent mutation of 'uuid'

  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.prevent_duplicate_conversation()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- Check if the new row violates the rule
  IF EXISTS (
    SELECT 1
    FROM public.conversation
    WHERE 
      (sender_uuid = NEW.sender_uuid AND receiver_uuid = NEW.receiver_uuid)
      OR
      (sender_uuid = NEW.receiver_uuid AND receiver_uuid = NEW.sender_uuid)
  ) THEN
    RAISE EXCEPTION 'Invalid conversation: sender and receiver combination is not allowed.';
  END IF;

  -- If the check passes, proceed with the operation
  RETURN NEW;
END;
$function$
;

grant delete on table "public"."conversation" to "anon";

grant insert on table "public"."conversation" to "anon";

grant references on table "public"."conversation" to "anon";

grant select on table "public"."conversation" to "anon";

grant trigger on table "public"."conversation" to "anon";

grant truncate on table "public"."conversation" to "anon";

grant update on table "public"."conversation" to "anon";

grant delete on table "public"."conversation" to "authenticated";

grant insert on table "public"."conversation" to "authenticated";

grant references on table "public"."conversation" to "authenticated";

grant select on table "public"."conversation" to "authenticated";

grant trigger on table "public"."conversation" to "authenticated";

grant truncate on table "public"."conversation" to "authenticated";

grant update on table "public"."conversation" to "authenticated";

grant delete on table "public"."conversation" to "service_role";

grant insert on table "public"."conversation" to "service_role";

grant references on table "public"."conversation" to "service_role";

grant select on table "public"."conversation" to "service_role";

grant trigger on table "public"."conversation" to "service_role";

grant truncate on table "public"."conversation" to "service_role";

grant update on table "public"."conversation" to "service_role";

grant delete on table "public"."message" to "anon";

grant insert on table "public"."message" to "anon";

grant references on table "public"."message" to "anon";

grant select on table "public"."message" to "anon";

grant trigger on table "public"."message" to "anon";

grant truncate on table "public"."message" to "anon";

grant update on table "public"."message" to "anon";

grant delete on table "public"."message" to "authenticated";

grant insert on table "public"."message" to "authenticated";

grant references on table "public"."message" to "authenticated";

grant select on table "public"."message" to "authenticated";

grant trigger on table "public"."message" to "authenticated";

grant truncate on table "public"."message" to "authenticated";

grant update on table "public"."message" to "authenticated";

grant delete on table "public"."message" to "service_role";

grant insert on table "public"."message" to "service_role";

grant references on table "public"."message" to "service_role";

grant select on table "public"."message" to "service_role";

grant trigger on table "public"."message" to "service_role";

grant truncate on table "public"."message" to "service_role";

grant update on table "public"."message" to "service_role";

create policy "Enable read for users is in the conversation"
on "public"."conversation"
as permissive
for select
to authenticated, anon
using (((auth.uid() = sender_uuid) OR (auth.uid() = receiver_uuid)));


create policy "Enable update for users are in conversation"
on "public"."conversation"
as permissive
for update
to anon, authenticated
using (((auth.uid() = sender_uuid) OR (auth.uid() = receiver_uuid)))
with check (((auth.uid() = sender_uuid) OR (auth.uid() = receiver_uuid)));


create policy "All access if user are in the conversation"
on "public"."message"
as permissive
for select
to anon, authenticated
using (((auth.uid() IN ( SELECT conversation.sender_uuid
   FROM conversation
  WHERE (conversation.uuid = message.conversation_uuid))) OR (auth.uid() IN ( SELECT conversation.receiver_uuid
   FROM conversation
  WHERE (conversation.uuid = message.conversation_uuid)))));


create policy "All user to create their own message"
on "public"."message"
as permissive
for select
to anon, authenticated
using ((auth.uid() = sender_uuid));


create policy "allow user to create message if the are in the conversation"
on "public"."message"
as permissive
for select
to authenticated, anon
using (((auth.uid() IN ( SELECT conversation.sender_uuid
   FROM conversation
  WHERE (conversation.uuid = message.conversation_uuid))) OR (auth.uid() IN ( SELECT conversation.receiver_uuid
   FROM conversation
  WHERE (conversation.uuid = message.conversation_uuid)))));


create policy "allow user to update own message"
on "public"."message"
as permissive
for update
to anon, authenticated
using ((auth.uid() = sender_uuid))
with check ((auth.uid() = sender_uuid));


CREATE TRIGGER on_conversation_update BEFORE UPDATE ON public.conversation FOR EACH ROW EXECUTE FUNCTION handle_conversation_update();

CREATE TRIGGER on_create_conversation BEFORE INSERT ON public.conversation FOR EACH ROW EXECUTE FUNCTION prevent_duplicate_conversation();

CREATE TRIGGER on_message_update BEFORE UPDATE ON public.message FOR EACH ROW EXECUTE FUNCTION handle_message_update();


